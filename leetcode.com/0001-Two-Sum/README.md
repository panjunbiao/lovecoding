# 题目：两数之和
给定一个数组和一个目标整数，要求函数返回两个数组下标，使得这两个下标所对应的数组元素之和等于所指定的整数。
原题：https://leetcode.com/problems/two-sum/

# 分析
数组长度最短是2：不用担心数组是空或者元素不够的情况。
数组长度最长是10000：不用担心内存问题。
数组元素和目标数字都在32位整数范围之内。
数据元素任意两个相加都不会超出32为整数的范围（不会溢出）。

# 解题
## 方法一：两重循环穷尽所有组合
计算机的优势不就是快么？所以我们首先可以尝试暴力求解，就是穷尽数组中的所有两两组合，看看有没有相加等于所指定的整数的组合。
一个循环可以穷尽数组所有的元素，而两重循环就可以穷尽两两组合。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length - 1; i ++) {
            for (int j = i + 1; j < nums.length; j ++) {
                if (nums[i] + nums[j] == target) {
                    return new int[] { i, j };
                }
            }
        }
        return new int[] { -1, -1 };
    }
}
```
时间复杂度：因为是两重循环，所以是O(N^2)，N是数组长度。
空间复杂度：消耗空间不会随着数组长度（N）增长，所以是O(1)。

## 方法二：利用哈希集合O(1)寻址优化时间复杂度
方法一中，我们使用了两重循环。有没有可能优化一下，只是用一个循环呢？这时候我们想起哈希集合，在集合中寻找一个数字的时间复杂度是O(1)。
然后我们发现，只需要把问题中的加法，转换一下就是减法问题（目标数字减去一个数组元素）。
```java
import java.util.HashMap;
class Solution {
    public int[] twoSum(int[] nums, int target) {
        var map = new HashMap<Integer, Integer>();
        map.put(nums[0], 0);
        for (int j = 1; j < nums.length; j ++) {
            var i = map.get(target - nums[j]);
            if (i != null) {
                return new int[] { i, j };
            }
            map.put(nums[j], j);
        }
        return new int[] { -1, -1 };
    }
}
```
这样一来，时间复杂度优化为O(N)，非常厉害了。
当然也有代价，就是空间复杂度现在变为O(N)了。

# 测试用例
首先从最简单的例子开始，只有两个元素
然后设计稍复杂的例子，有三个数组元素
最后更复杂的例子，有四个数组元素。
设计目标数字的时候，最好能够想到各种下标组合，特别是数组头尾、中间之类的组合。

```
[1,2]
3
[1,2,3]
4
[1,2,3]
5
[1,3,5,8]
8
[1,3,5,8]
9
```

# 延申讨论
在日常的工作中，我们几乎肯定回选择方法二。但这并不是说方法一就一无是处。
想象一下在某些情况下（例如我们不小心成为了电影The Martian的主角），只有一部非常原始的计算机，可能连哈希函数都没有，或者内存空间非常有限，或者数组长度也不是太长，那么方法一还是可行的。